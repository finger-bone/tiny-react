这篇文章是关于如何构建一个类似于React的前端框架，以展示React的内部工作原理。本章将重点介绍JSX。

我将使用Bun作为运行时。Node可能需要额外的配置来支持TypeScript和编译。

## JSX

在我们深入讨论之前，让我们先来看看React中JSX的几个重要元素。

如果你曾经查看过React组件的转译代码，你会看到它只是一堆函数调用。JSX只是`React.createElement`的语法糖。例如，下面的JSX代码：

```jsx
const element = <h1 className="greeting">Hello, world!</h1>;
```

将被转译为：

```js
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```

`React.createElement`函数将创建一个虚拟元素，这是另一个核心机制。简单来说，虚拟元素就是虚拟DOM中的元素。虚拟DOM是代表实际DOM的某种东西。由于操作虚拟DOM本质上是操作JavaScript对象，它比操作实际DOM要快得多。我们将在下一章讨论虚拟DOM。但现在，知道JSX只是`React.createElement`的语法糖就足够了。

`React.createElement`函数按顺序接受以下参数：

1. 元素的标签名。有些标签是特殊的，比如`div`、`span`、`h1`等。这些被称为内置元素。有些标签是用户自定义组件。
2. 元素的属性。这是一个包含元素属性的对象。例如，上面`h1`元素的`className`属性是`greeting`。
3. 元素的子元素。这可以是字符串或元素。请注意，这个参数在函数签名中表示为`...children`，这意味着它可以接收任意数量的参数。

听起来是个简单的工作，对吧？那我们来做吧。

## 实现JSX

当涉及到编译时，我们可以指定要使用的函数——默认情况下，函数是`React.createElement`。但我们可以使用自己的函数。

所以我们创建一个`v-dom.ts`文件，以便首先定义虚拟元素。

```typescript
export type VDomAttributes = { 
    key?: string | number
    [_: string]: string | number | boolean | Function | undefined
}

export interface VDomElement {
  kind: 'element'
  tag: string
  children?: VDomNode[]
  props?: VDomAttributes
  key: string | number | undefined
}

export type VDomNode = 
| string
| VDomElement
```

请注意，我们在每个节点中都有一个`key`字段（节点只是文本或元素的名称）。这是为了协调，我们将在下一章讨论。现在你可以暂时忽略它。

现在我们可以实现`createElement`函数。我们将它放在同一个文件中。

```typescript

export function createElement(tag: string, props: VDomAttributes, ...children: VDomNode[]): VDomElement {
  console.log('createElement', tag, props, children)
    return {
        kind: 'element',
        tag,
        children,
        props,
        key: props?.key ?? undefined
    }
}
```

现在我们指示编译器使用这个函数。我们可以通过在文件顶部添加以下行来做到这一点。

```typescript
import { createElement as h } from './v-dom'
```

请注意，由于我们采用React标准，我们需要引入React类型定义。我们可以通过在文件顶部添加以下行来做到这一点。

```bash
bun i @types/react
```

然后在`tsconfig.json`中，我们在`compilerOptions`字段中添加以下行。

```json
"compilerOptions": {
    "jsx": "react",
    "jsxFactory": "createElement",
}
```

现在，我们可以看看我们创建的虚拟元素。

```tsx
import { createElement } from "./v-dom";

function App() {
    return <div>
        <h1>a</h1>
        <h2>b</h2>
    </div>
}

console.log(App());
```

你将看到基于JSX代码的我们定义的虚拟DOM元素。

此外，我们还可以定义一个片段元素——`<></>`，如果你不知道它的官方名称。我们可以通过在文件顶部添加以下行来做到这一点。

片段也需要创建函数——它只是一个具有不同签名的函数。要支持片段，我们需要对我们当前的代码做一些小改动。这非常简单，所以我这里不会详细说明。

```typescript
export type VDomAttributes = { 
    key?: string | number
    [_: string]: string | number | boolean | Function | undefined
}

export interface VDomElement {
  kind: 'element' | 'fragment'
  tag: string
  children?: VDomNode[]
  props?: VDomAttributes
  key: string | number | undefined
}

export type VDomNode = 
| string
| VDomElement

export function createElement(tag: string, props: VDomAttributes, ...children: VDomNode[]): VDomElement {
    console.log('createElement', tag, props, children);
    return {
        kind: tag === '' ? 'fragment' : 'element',
        tag,
        children,
        props: props ?? {},
        key: props?.key ?? undefined
    }
}

export const fragment = ''
```

额外的编译器选项，

```json
"jsxFragmentFactory": "fragment"
```

基本上，片段只是一个带有空标签的特殊元素。当创建片段时，编译器将获取`jsxFragmentFactory`并将其放入`createElement`的第一个参数的标签参数中。因此我们可以很容易地区分片段和其他元素。

```tsx
import { createElement, fragment } from "./v-dom";

function App() {
    return <>
        <h1>a</h1>
        <h2>b</h2>
    </>
}

console.log(App());
```

这段代码将正确地产生虚拟DOM。到目前为止，我们已经实现了我们微小的React的JSX部分。

## 脚注

呃，这是第三章的作者。实际上，目前的JSX实现并不完美。我们将在第三章修复它。现在它不支持像这样的语法，

```tsx
<div>
    {[1, 2, 3].map(i => <span>{i}</span>)}
</div>
```

这是因为每个`{}`都视为一个子节点，但是吧，`map`返回数组，这样就导致实际上传入`createElement`的参数是嵌套的数组。我们需要展平。这是一个简单的修复。然而，直到第三章我才注意到这一点。所以，呃，你可以按照当前的来做，以后再修复。对于造成的不便，我表示歉意。
