{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tiny React This series implements the core of React from the very beginning. It is a good way to understand how React works under the hood. This tutorial is based on this article , but with JSX, typescript, and more into the coding details. JSX Rendering vDOM Updating vDOM Hooks","title":"Tiny React"},{"location":"#tiny-react","text":"This series implements the core of React from the very beginning. It is a good way to understand how React works under the hood. This tutorial is based on this article , but with JSX, typescript, and more into the coding details. JSX Rendering vDOM Updating vDOM Hooks","title":"Tiny React"},{"location":"01/","text":"Tiny React Ch1 JSX This series will build a tiny frontend framework, functionally similar to React, to illustrate how React works under the hood. This chapter overs JSX. I will use Bun as runtime. Node may need extra configuration for typescript and compiling. JSX Now, before we go any deeper, let's look at several important element of react- jsx first. If you ever took a look at the transpiled code of a React component, you will see that it is just a bunch of function calls. JSX is just a syntactic sugar for React.createElement . That is, for exmaple, the following JSX code: const element = <h1 className=\"greeting\">Hello, world!</h1>; Will be transpiled to: const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!' ); React.createElement will create a virtual element, which is another core mechanism. To put it simply, virtual element is the element in virtual DOM. A virtual DOM is something that represents the actual DOM. Since operating on virtual DOM is simply operating js objects, it is much faster than operating on actual DOM. We will talk about virtual DOM in the next chapter. But for now, knowing that JSX is just a syntax sugar for React.createElement is enough. The React.createElement function takes the following arguments in order, The tag name of the element. Some tags are special, like div , span , h1 , etc. These are called intrinsic elements. Some tags are user-defined components. The props of the element. This is an object that contains the properties of the element. For example, the className of the h1 element above is greeting . The children of the element. This can be string or element. Please note that this parameter is represented as ...children in the function signature, which means that it can take any number of arguments. It sounds an easy job, right? So let's do it. Implement JSX When it comes to compilation, we can specify the function to use- by default, the function is React.createElement . But we can use our own function. So we create a v-dom.ts , so as to define the virtual element first. export type VDomAttributes = { key?: string | number [_: string]: string | number | boolean | Function | undefined } export interface VDomElement { kind: 'element' tag: string children?: VDomNode[] props?: VDomAttributes key: string | number | undefined } export type VDomNode = | string | VDomElement Please note that we have a key field in each node (node is just a name for either text or element). This is for reconciliation, which we will talk about in the next chapter. You can safely ignore it for now. Now we can implement the createElement function. We put it in the same file. export function createElement(tag: string, props: VDomAttributes, ...children: VDomNode[]): VDomElement { console.log('createElement', tag, props, children) return { kind: 'element', tag, children, props, key: props?.key ?? undefined } } Now we instruct our compiler to use this function. We can do this by adding the following line to the top of our file. import { createElement as h } from './v-dom' Please note that since we are adopting react standard, we need to introduce the React type definition. We can do this by adding the following line to the top of our file. bun i @types/react Then in the tsconfig.json , we add the following line to the compilerOptions field. \"compilerOptions\": { \"jsx\": \"react\", \"jsxFactory\": \"createElement\", } Now, we can take a look at the virtual element we created. import { createElement } from \"./v-dom\"; function App() { return <div> <h1>a</h1> <h2>b</h2> </div> } console.log(App()); You will see just our defined virtual dom element based on the JSX code. Furthermore, we can also define a fragment element- the <> , if you don't know its official name. We can do this by adding the following line to the top of our file. When dealing with fragment, the compiler will take the configured fragment factory to the tag in the element creation function. This is the same as how functional components work- functional component will take the function to the tag, which we will demonstrate in the next chapter. Nonetheless, in our implementation, there is no need for complex handling- we just need to set a special tag for fragment. export type VDomAttributes = { key?: string | number [_: string]: string | number | boolean | Function | undefined } export interface VDomElement { kind: 'element' | 'fragment' tag: string children?: VDomNode[] props?: VDomAttributes key: string | number | undefined } export type VDomNode = | string | VDomElement export function createElement(tag: string, props: VDomAttributes, ...children: VDomNode[]): VDomElement { console.log('createElement', tag, props, children); return { kind: tag === '' ? 'fragment' : 'element', tag, children, props: props ?? {}, key: props?.key ?? undefined } } export const fragment = '' Extra compiler options, \"jsxFragmentFactory\": \"fragment\" Basically, fragment is just a special element with an empty tag. When it comes to the creation of fragment, the compiler will fetch the jsxFragmentFactory and put it into the tag parameter in the first parameter of createElement . So we can easily distinguish fragment from other elements. import { createElement, fragment } from \"./v-dom\"; function App() { return <> <h1>a</h1> <h2>b</h2> </> } console.log(App()); This code will correct yield the virtual DOM. So far, we have implemented the JSX part of our tiny react. Footnote Ugh, this is the author from chapter three. Actually, the current implementation of JSX is not perfect. We will fix it in the third chapter. Now it does not support syntax like, <div> {[1, 2, 3].map(i => <span>{i}</span>)} </div> This is because every {} is treated as one child, where as the map returns an array. So it will have nested children. Also we hadn't supported functional components yet, which is in the next chapter. You can just follow the current one and fix it later. Sorry for the inconvenience.","title":"JSX"},{"location":"01/#tiny-react-ch1-jsx","text":"This series will build a tiny frontend framework, functionally similar to React, to illustrate how React works under the hood. This chapter overs JSX. I will use Bun as runtime. Node may need extra configuration for typescript and compiling.","title":"Tiny React Ch1 JSX"},{"location":"01/#jsx","text":"Now, before we go any deeper, let's look at several important element of react- jsx first. If you ever took a look at the transpiled code of a React component, you will see that it is just a bunch of function calls. JSX is just a syntactic sugar for React.createElement . That is, for exmaple, the following JSX code: const element = <h1 className=\"greeting\">Hello, world!</h1>; Will be transpiled to: const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!' ); React.createElement will create a virtual element, which is another core mechanism. To put it simply, virtual element is the element in virtual DOM. A virtual DOM is something that represents the actual DOM. Since operating on virtual DOM is simply operating js objects, it is much faster than operating on actual DOM. We will talk about virtual DOM in the next chapter. But for now, knowing that JSX is just a syntax sugar for React.createElement is enough. The React.createElement function takes the following arguments in order, The tag name of the element. Some tags are special, like div , span , h1 , etc. These are called intrinsic elements. Some tags are user-defined components. The props of the element. This is an object that contains the properties of the element. For example, the className of the h1 element above is greeting . The children of the element. This can be string or element. Please note that this parameter is represented as ...children in the function signature, which means that it can take any number of arguments. It sounds an easy job, right? So let's do it.","title":"JSX"},{"location":"01/#implement-jsx","text":"When it comes to compilation, we can specify the function to use- by default, the function is React.createElement . But we can use our own function. So we create a v-dom.ts , so as to define the virtual element first. export type VDomAttributes = { key?: string | number [_: string]: string | number | boolean | Function | undefined } export interface VDomElement { kind: 'element' tag: string children?: VDomNode[] props?: VDomAttributes key: string | number | undefined } export type VDomNode = | string | VDomElement Please note that we have a key field in each node (node is just a name for either text or element). This is for reconciliation, which we will talk about in the next chapter. You can safely ignore it for now. Now we can implement the createElement function. We put it in the same file. export function createElement(tag: string, props: VDomAttributes, ...children: VDomNode[]): VDomElement { console.log('createElement', tag, props, children) return { kind: 'element', tag, children, props, key: props?.key ?? undefined } } Now we instruct our compiler to use this function. We can do this by adding the following line to the top of our file. import { createElement as h } from './v-dom' Please note that since we are adopting react standard, we need to introduce the React type definition. We can do this by adding the following line to the top of our file. bun i @types/react Then in the tsconfig.json , we add the following line to the compilerOptions field. \"compilerOptions\": { \"jsx\": \"react\", \"jsxFactory\": \"createElement\", } Now, we can take a look at the virtual element we created. import { createElement } from \"./v-dom\"; function App() { return <div> <h1>a</h1> <h2>b</h2> </div> } console.log(App()); You will see just our defined virtual dom element based on the JSX code. Furthermore, we can also define a fragment element- the <> , if you don't know its official name. We can do this by adding the following line to the top of our file. When dealing with fragment, the compiler will take the configured fragment factory to the tag in the element creation function. This is the same as how functional components work- functional component will take the function to the tag, which we will demonstrate in the next chapter. Nonetheless, in our implementation, there is no need for complex handling- we just need to set a special tag for fragment. export type VDomAttributes = { key?: string | number [_: string]: string | number | boolean | Function | undefined } export interface VDomElement { kind: 'element' | 'fragment' tag: string children?: VDomNode[] props?: VDomAttributes key: string | number | undefined } export type VDomNode = | string | VDomElement export function createElement(tag: string, props: VDomAttributes, ...children: VDomNode[]): VDomElement { console.log('createElement', tag, props, children); return { kind: tag === '' ? 'fragment' : 'element', tag, children, props: props ?? {}, key: props?.key ?? undefined } } export const fragment = '' Extra compiler options, \"jsxFragmentFactory\": \"fragment\" Basically, fragment is just a special element with an empty tag. When it comes to the creation of fragment, the compiler will fetch the jsxFragmentFactory and put it into the tag parameter in the first parameter of createElement . So we can easily distinguish fragment from other elements. import { createElement, fragment } from \"./v-dom\"; function App() { return <> <h1>a</h1> <h2>b</h2> </> } console.log(App()); This code will correct yield the virtual DOM. So far, we have implemented the JSX part of our tiny react.","title":"Implement JSX"},{"location":"01/#footnote","text":"Ugh, this is the author from chapter three. Actually, the current implementation of JSX is not perfect. We will fix it in the third chapter. Now it does not support syntax like, <div> {[1, 2, 3].map(i => <span>{i}</span>)} </div> This is because every {} is treated as one child, where as the map returns an array. So it will have nested children. Also we hadn't supported functional components yet, which is in the next chapter. You can just follow the current one and fix it later. Sorry for the inconvenience.","title":"Footnote"},{"location":"02/","text":"Tiny React Ch2 Rendering vDOM This part we will render the vDOM to the actual DOM. In addition, we will also introduce fiber tree, which a core structure in React. Rendering vDOM Rendering vDOM is, simple- too simple. You need to know the following web native APIs. document.createElement(tagName: string): HTMLElement Creates an actual DOM element. document.createTextNode(text: string): Text Creates a text node. .appendChild(child: Node): void Appends a child node to the parent node. A method on HTMLElement .removeChild(child: Node): void Removes a child node from the parent node. A method on HTMLElement .replaceChild(newChild: Node, oldChild: Node): void Replaces a child node with a new child node. A method on HTMLElement .replaceWith(...nodes: Node[]): void Replaces a node with new nodes. A method on Node .remove(): void Removes a node from the document. A method on Node .insertBefore(newChild: Node, refChild: Node): void Inserts a new child node before a reference child node. A method on HTMLElement .setAttribute(name: string, value: string): void Sets an attribute on an element. A method on HTMLElement . .removeAttribute(name: string): void Removes an attribute from an element. A method on HTMLElement . .addEventListener(type: string, listener: Function): void Adds an event listener to an element. A method on HTMLElement . .removeEventListener(type: string, listener: Function): void Removes an event listener from an element. A method on HTMLElement . .dispatchEvent(event: Event): void Dispatches an event on an element. A method on HTMLElement . Woa, a bit too much, right? But all you need to do is mirroring the creation of vDOM to the actual DOM. Here is a simple example. function render(vDom: VDomNode, parent: HTMLElement) { if (typeof vDom === 'string') { parent.appendChild(document.createTextNode(vDom)) } else if (vDom.kind === 'element') { const element = document.createElement(vDom.tag) for (const [key, value] of Object.entries(vDom.props ?? {})) { if (key === 'key') continue if (key.startsWith('on')) { element.addEventListener(key.slice(2).toLowerCase(), value as EventListener) } else { element.setAttribute(key, value as string) } } for (const child of vDom.children ?? []) { render(child, element) } parent.appendChild(element) } else { for (const child of vDom.children ?? []) { render(child, parent) } } } We registered properties starting with on as event listeners, this is a common practice in React. Also, we ignored the key property, which is used for reconciliation, not for rendering. Okay, so rendering done and this chapter ends...? No. Idle Time Rendering In real react, the rendering process is a bit more complicated. To be more specific, it will use requestIdleCallback , to make more urgent tasks to be done first, lowering its own priority. Please note that requestIdleCallback is not supported on Safari, on both MacOS and iOS (Apple Engineers, please, why? At least they are working on it, at 2024). If you are on a Mac, use chrome, or replace it with a simple setTimeout . In real react, it uses scheduler to handle this, but the basic idea is the same. To do so, we need to know the following web native APIs. requestIdleCallback(callback: Function): void Requests a callback to be called when the browser is idle. The callback will be passed an IdleDeadline object. The callback will have a deadline argument, which is an object with the following properties. timeRemaining(): number Returns the time remaining in milliseconds before the browser is no longer idle. So we should finish our work before the time is up. So we need to split our rendering in chunks, and use requestIdleCallback to handle it. A simple way would be to just render one node at a time. It is easy- but do not be eager to do so- or you'll waste a lot of time, since we also need other work to be done while rendering. But we can have the following code as a basic framework for what we are going to do. import { createDom, VDomNode } from \"./v-dom\" interface Fiber { parent: Fiber | null sibling: Fiber | null child: Fiber | null vDom: VDomNode, dom: HTMLElement | Text | null } let nextUnitOfWork: Fiber | null = null function workLoop(deadline: IdleDeadline) { let shouldYield = false while (nextUnitOfWork && !shouldYield) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) shouldYield = deadline.timeRemaining() < 1 } requestIdleCallback(workLoop) } requestIdleCallback(workLoop) function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { // TODO throw new Error('Not implemented') } If you now fill // TODO with rendering vDOM, and return the next vDOM node to be rendered, you can have a simple idle time rendering. But don't be hasty- we need more work. Fiber Tree In the next chapter, we will implement reactivity, and the reconciliation is rather complicated- so we move some content into this part, that is the fiber tree. Fiber tree is just a special data structure. When react handles changes, it does the following process. Something, may be a user, or initial rendering, triggers a change. React creates a new vDOM tree. React calculate the new fiber tree. React calculates the difference between the old fiber tree and the new fiber tree. React applies the difference to the actual DOM. You can see, fiber tree is essential for React. The fiber tree, a little bit different from traditional tree, has three types of relations between nodes. child of: A node is a child of another node. Please note that, in fiber tree, every node can have only one child. The traditional tree structure is represented by a child with many siblings. sibling of: A node is a sibling of another node. parent of: A node is a parent of another node. Different from child of, many nodes can share the same parent. You can think parent node in fiber tree as a bad parent, who only cares about the first child, but is still, in fact, parent of many children. For example, for the following DOM, <div> <p></p> <div> <h1></h1> <h2></h2> </div> </div> We can represent it as a tree. div \u251c\u2500\u2500 p \u2514\u2500\u2500 div \u251c\u2500\u2500 h1 \u2514\u2500\u2500 h2 p is a child of the root div , but the secondary div is not a child of the root div , but a sibling of p . h1 and h2 are children of the secondary div . When it comes to rendering, the order is mainly depth-first, but kind of different- so basically, it follows these rules. For each node, it goes through the following steps. If this node has a unprocessed child, process the child. If this node has a sibling, process the sibling. Repeat until all siblings are processed. Mark this node as processed. Process its parent. Now let's implement that. But first, we need to trigger the rendering process. It is simple- just set the nextUnitOfWork to the root of the fiber tree. export function render(vDom: VDomNode, parent: HTMLElement) { nextUnitOfWork = { parent: null, sibling: null, child: null, vDom: vDom, dom: parent } } After triggering the rendering, browser will call performUnitOfWork , this is where we, well, perform the work. The first is that we need to create actual DOM elements. We can do this by creating a new DOM element, and append it to the parent DOM element. function isString(value: VDomNode): value is string { return typeof value === 'string' } function isElement(value: VDomNode): value is VDomElement { return typeof value === 'object' } export function createDom(vDom: VDomNode): HTMLElement | Text | DocumentFragment { if (isString(vDom)) { return document.createTextNode(vDom) } else if (isElement(vDom)) { const element = document.createElement(vDom.tag === '' ? 'div' : vDom.tag) Object.entries(vDom.props ?? {}).forEach(([name, value]) => { if (value === undefined) return if (name === 'key') return if (name.startsWith('on') && value instanceof Function) { element.addEventListener(name.slice(2).toLowerCase(), value as EventListener) } else { element.setAttribute(name, value.toString()) } }) return element } else { throw new Error('Unexpected vDom type') } } function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { if(!nextUnitOfWork) { return null } if(!nextUnitOfWork.dom) { nextUnitOfWork.dom = createDom(nextUnitOfWork.vDom) } if(nextUnitOfWork.parent && nextUnitOfWork.parent.dom) { nextUnitOfWork.parent.dom.appendChild(nextUnitOfWork.dom) } // TODO throw new Error('Not implemented') } This is the first part of the work. Now we need to construct the fiber branching out from the current one. const fiber = nextUnitOfWork if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: fiber, dom: null, sibling: null, child: null, vDom: element, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber index++ } } Now we have a fiber tree built for the current node. Now let's follow our rules to process the fiber tree. if (fiber.child) { return fiber.child } let nextFiber: Fiber | null = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } return null Now we can render the vDOM, here it is. Please note that typescript is being stupid here since it can not tell the type of our virtual DOM, we need an ugly bypass here. import { render } from \"./runtime\"; import { createElement, fragment, VDomNode } from \"./v-dom\"; function App() { return <> <h1>a</h1> <h2>b</h2> </> } const app = document.getElementById('app') const vDom: VDomNode = App() as unknown as VDomNode render(vDom, app!) Now your vDOM is rendered to the actual DOM. Congratulations! You have done a great job. But we are not done yet. Cumulative Commit There will be a problem with the current implementation- if we have too many nodes that slows the whole process down, the user will see how the rendering is done. Of course, it won't leak commercial secrets or something, but it is not a good experience. We'd rather hide the dom creation behind the curtain, the submit it all at once. The solution is simple- instead of directly committing to the document, we create an element without adding it to the document, and when we are done, we add it to the document. This is called cumulative commit. let wip: Fiber | null = null let wipParent: HTMLElement | null = null export function render(vDom: VDomNode, parent: HTMLElement) { wip = { parent: null, sibling: null, child: null, vDom: vDom, dom: null, } wipParent = parent nextUnitOfWork = wip } Now, we remove the appendChild from performUnitOfWork , that is, the following part, if(nextUnitOfWork.parent && nextUnitOfWork.parent.dom) { nextUnitOfWork.parent.dom.appendChild(nextUnitOfWork.dom) } Now if we finish all the work, we have all the fiber correctly built up with their DOM, but they are not added to the document. When such event dispatches, we call a commit function, which will add the DOM to the document. function commit() { } function workLoop(deadline: IdleDeadline) { let shouldYield = false while (nextUnitOfWork && !shouldYield) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) if(!nextUnitOfWork && wip) { commit() } shouldYield = deadline.timeRemaining() < 1 } requestIdleCallback(workLoop) } Now, the commit function is simple- just add all the children DOM recursively to the wip , then commit wip to the DOM. function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent.dom.appendChild(fiber.dom) } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip = null } You can test this out by adding a timeout to commitChildren function. previously, the rendering was done step by step, but now it is done all at once. Nested Components You may try nested functions- like the following, import { render } from \"./runtime\"; import { createElement, fragment, VDomNode } from \"./v-dom\"; function App() { return <> <h1>a</h1> <h2>b</h2> <div> <h3>c</h3> </div> </> } function Wrapper() { return <div> <h1>a</h1> <h2>b</h2> <div> <h3><App/></h3> </div> </div> } const app = document.getElementById('app') const vDom: VDomNode = Wrapper() as unknown as VDomNode render(vDom, app!) But it won't work, since when parsing the JSX, tag is just the label name. Sure, for native elements, it is just a string, but for components, it is a function. So in the process of converting JSX to vDOM, we need to check if the tag is a function, and if so, call it. export function createElement(tag: string | Function, props: VDomAttributes, ...children: VDomNode[]): VDomElement { if (tag instanceof Function) { return tag(props, children) } return { kind: tag === '' ? 'fragment' : 'element', tag, children, props: props ?? {}, key: props?.key ?? undefined } } Now, props and children are required for each component. In real React, they added extra field to check- you can imagine, just by replacing functions with classes, so you have extra fields- then you provide new function to create objects, a typical factory pattern- but we take a lazy we here. import { render } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; type FuncComponent = (props: VDomAttributes, children: VDomNode[]) => JSX.Element const Wrapper: FuncComponent = (_: VDomAttributes, __: VDomNode[]) => { return <div> <> <p>aa</p> </> </div> } const app = document.getElementById('app') const vDom: VDomNode = Wrapper({}, []) as unknown as VDomNode console.log(vDom) render(vDom, app!) Please note that in the real React, the function component call is delayed to the fiber building stage. Nonetheless, we did so for convenience, and it doesn't really harm the purpose of this series. Fragment However, it's still not enough. Previously, we just treated fragment as div , which is not correct. But if you just replace that with a document fragment, it won't work. The reason for this is because fragments is a one-time container- which leads to a strange behaviour- like you cannot take real things out of it, and you can not nest them, and many strange things (really, why it just won't work simpler...). So, fuck, we need to dig this shit up. So the solution is that, we do not create DOM for fragment- we find the correct parent to add the DOM. We need, export function isFragment(value: VDomNode): value is VDomElement { return isElement(value) && value.kind === 'fragment' } And change the rendering, function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom)) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip = null } Now, the fragment is correctly handled.","title":"Rendering vDOM"},{"location":"02/#tiny-react-ch2-rendering-vdom","text":"This part we will render the vDOM to the actual DOM. In addition, we will also introduce fiber tree, which a core structure in React.","title":"Tiny React Ch2 Rendering vDOM"},{"location":"02/#rendering-vdom","text":"Rendering vDOM is, simple- too simple. You need to know the following web native APIs. document.createElement(tagName: string): HTMLElement Creates an actual DOM element. document.createTextNode(text: string): Text Creates a text node. .appendChild(child: Node): void Appends a child node to the parent node. A method on HTMLElement .removeChild(child: Node): void Removes a child node from the parent node. A method on HTMLElement .replaceChild(newChild: Node, oldChild: Node): void Replaces a child node with a new child node. A method on HTMLElement .replaceWith(...nodes: Node[]): void Replaces a node with new nodes. A method on Node .remove(): void Removes a node from the document. A method on Node .insertBefore(newChild: Node, refChild: Node): void Inserts a new child node before a reference child node. A method on HTMLElement .setAttribute(name: string, value: string): void Sets an attribute on an element. A method on HTMLElement . .removeAttribute(name: string): void Removes an attribute from an element. A method on HTMLElement . .addEventListener(type: string, listener: Function): void Adds an event listener to an element. A method on HTMLElement . .removeEventListener(type: string, listener: Function): void Removes an event listener from an element. A method on HTMLElement . .dispatchEvent(event: Event): void Dispatches an event on an element. A method on HTMLElement . Woa, a bit too much, right? But all you need to do is mirroring the creation of vDOM to the actual DOM. Here is a simple example. function render(vDom: VDomNode, parent: HTMLElement) { if (typeof vDom === 'string') { parent.appendChild(document.createTextNode(vDom)) } else if (vDom.kind === 'element') { const element = document.createElement(vDom.tag) for (const [key, value] of Object.entries(vDom.props ?? {})) { if (key === 'key') continue if (key.startsWith('on')) { element.addEventListener(key.slice(2).toLowerCase(), value as EventListener) } else { element.setAttribute(key, value as string) } } for (const child of vDom.children ?? []) { render(child, element) } parent.appendChild(element) } else { for (const child of vDom.children ?? []) { render(child, parent) } } } We registered properties starting with on as event listeners, this is a common practice in React. Also, we ignored the key property, which is used for reconciliation, not for rendering. Okay, so rendering done and this chapter ends...? No.","title":"Rendering vDOM"},{"location":"02/#idle-time-rendering","text":"In real react, the rendering process is a bit more complicated. To be more specific, it will use requestIdleCallback , to make more urgent tasks to be done first, lowering its own priority. Please note that requestIdleCallback is not supported on Safari, on both MacOS and iOS (Apple Engineers, please, why? At least they are working on it, at 2024). If you are on a Mac, use chrome, or replace it with a simple setTimeout . In real react, it uses scheduler to handle this, but the basic idea is the same. To do so, we need to know the following web native APIs. requestIdleCallback(callback: Function): void Requests a callback to be called when the browser is idle. The callback will be passed an IdleDeadline object. The callback will have a deadline argument, which is an object with the following properties. timeRemaining(): number Returns the time remaining in milliseconds before the browser is no longer idle. So we should finish our work before the time is up. So we need to split our rendering in chunks, and use requestIdleCallback to handle it. A simple way would be to just render one node at a time. It is easy- but do not be eager to do so- or you'll waste a lot of time, since we also need other work to be done while rendering. But we can have the following code as a basic framework for what we are going to do. import { createDom, VDomNode } from \"./v-dom\" interface Fiber { parent: Fiber | null sibling: Fiber | null child: Fiber | null vDom: VDomNode, dom: HTMLElement | Text | null } let nextUnitOfWork: Fiber | null = null function workLoop(deadline: IdleDeadline) { let shouldYield = false while (nextUnitOfWork && !shouldYield) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) shouldYield = deadline.timeRemaining() < 1 } requestIdleCallback(workLoop) } requestIdleCallback(workLoop) function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { // TODO throw new Error('Not implemented') } If you now fill // TODO with rendering vDOM, and return the next vDOM node to be rendered, you can have a simple idle time rendering. But don't be hasty- we need more work.","title":"Idle Time Rendering"},{"location":"02/#fiber-tree","text":"In the next chapter, we will implement reactivity, and the reconciliation is rather complicated- so we move some content into this part, that is the fiber tree. Fiber tree is just a special data structure. When react handles changes, it does the following process. Something, may be a user, or initial rendering, triggers a change. React creates a new vDOM tree. React calculate the new fiber tree. React calculates the difference between the old fiber tree and the new fiber tree. React applies the difference to the actual DOM. You can see, fiber tree is essential for React. The fiber tree, a little bit different from traditional tree, has three types of relations between nodes. child of: A node is a child of another node. Please note that, in fiber tree, every node can have only one child. The traditional tree structure is represented by a child with many siblings. sibling of: A node is a sibling of another node. parent of: A node is a parent of another node. Different from child of, many nodes can share the same parent. You can think parent node in fiber tree as a bad parent, who only cares about the first child, but is still, in fact, parent of many children. For example, for the following DOM, <div> <p></p> <div> <h1></h1> <h2></h2> </div> </div> We can represent it as a tree. div \u251c\u2500\u2500 p \u2514\u2500\u2500 div \u251c\u2500\u2500 h1 \u2514\u2500\u2500 h2 p is a child of the root div , but the secondary div is not a child of the root div , but a sibling of p . h1 and h2 are children of the secondary div . When it comes to rendering, the order is mainly depth-first, but kind of different- so basically, it follows these rules. For each node, it goes through the following steps. If this node has a unprocessed child, process the child. If this node has a sibling, process the sibling. Repeat until all siblings are processed. Mark this node as processed. Process its parent. Now let's implement that. But first, we need to trigger the rendering process. It is simple- just set the nextUnitOfWork to the root of the fiber tree. export function render(vDom: VDomNode, parent: HTMLElement) { nextUnitOfWork = { parent: null, sibling: null, child: null, vDom: vDom, dom: parent } } After triggering the rendering, browser will call performUnitOfWork , this is where we, well, perform the work. The first is that we need to create actual DOM elements. We can do this by creating a new DOM element, and append it to the parent DOM element. function isString(value: VDomNode): value is string { return typeof value === 'string' } function isElement(value: VDomNode): value is VDomElement { return typeof value === 'object' } export function createDom(vDom: VDomNode): HTMLElement | Text | DocumentFragment { if (isString(vDom)) { return document.createTextNode(vDom) } else if (isElement(vDom)) { const element = document.createElement(vDom.tag === '' ? 'div' : vDom.tag) Object.entries(vDom.props ?? {}).forEach(([name, value]) => { if (value === undefined) return if (name === 'key') return if (name.startsWith('on') && value instanceof Function) { element.addEventListener(name.slice(2).toLowerCase(), value as EventListener) } else { element.setAttribute(name, value.toString()) } }) return element } else { throw new Error('Unexpected vDom type') } } function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { if(!nextUnitOfWork) { return null } if(!nextUnitOfWork.dom) { nextUnitOfWork.dom = createDom(nextUnitOfWork.vDom) } if(nextUnitOfWork.parent && nextUnitOfWork.parent.dom) { nextUnitOfWork.parent.dom.appendChild(nextUnitOfWork.dom) } // TODO throw new Error('Not implemented') } This is the first part of the work. Now we need to construct the fiber branching out from the current one. const fiber = nextUnitOfWork if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: fiber, dom: null, sibling: null, child: null, vDom: element, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber index++ } } Now we have a fiber tree built for the current node. Now let's follow our rules to process the fiber tree. if (fiber.child) { return fiber.child } let nextFiber: Fiber | null = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } return null Now we can render the vDOM, here it is. Please note that typescript is being stupid here since it can not tell the type of our virtual DOM, we need an ugly bypass here. import { render } from \"./runtime\"; import { createElement, fragment, VDomNode } from \"./v-dom\"; function App() { return <> <h1>a</h1> <h2>b</h2> </> } const app = document.getElementById('app') const vDom: VDomNode = App() as unknown as VDomNode render(vDom, app!) Now your vDOM is rendered to the actual DOM. Congratulations! You have done a great job. But we are not done yet.","title":"Fiber Tree"},{"location":"02/#cumulative-commit","text":"There will be a problem with the current implementation- if we have too many nodes that slows the whole process down, the user will see how the rendering is done. Of course, it won't leak commercial secrets or something, but it is not a good experience. We'd rather hide the dom creation behind the curtain, the submit it all at once. The solution is simple- instead of directly committing to the document, we create an element without adding it to the document, and when we are done, we add it to the document. This is called cumulative commit. let wip: Fiber | null = null let wipParent: HTMLElement | null = null export function render(vDom: VDomNode, parent: HTMLElement) { wip = { parent: null, sibling: null, child: null, vDom: vDom, dom: null, } wipParent = parent nextUnitOfWork = wip } Now, we remove the appendChild from performUnitOfWork , that is, the following part, if(nextUnitOfWork.parent && nextUnitOfWork.parent.dom) { nextUnitOfWork.parent.dom.appendChild(nextUnitOfWork.dom) } Now if we finish all the work, we have all the fiber correctly built up with their DOM, but they are not added to the document. When such event dispatches, we call a commit function, which will add the DOM to the document. function commit() { } function workLoop(deadline: IdleDeadline) { let shouldYield = false while (nextUnitOfWork && !shouldYield) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) if(!nextUnitOfWork && wip) { commit() } shouldYield = deadline.timeRemaining() < 1 } requestIdleCallback(workLoop) } Now, the commit function is simple- just add all the children DOM recursively to the wip , then commit wip to the DOM. function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent.dom.appendChild(fiber.dom) } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip = null } You can test this out by adding a timeout to commitChildren function. previously, the rendering was done step by step, but now it is done all at once.","title":"Cumulative Commit"},{"location":"02/#nested-components","text":"You may try nested functions- like the following, import { render } from \"./runtime\"; import { createElement, fragment, VDomNode } from \"./v-dom\"; function App() { return <> <h1>a</h1> <h2>b</h2> <div> <h3>c</h3> </div> </> } function Wrapper() { return <div> <h1>a</h1> <h2>b</h2> <div> <h3><App/></h3> </div> </div> } const app = document.getElementById('app') const vDom: VDomNode = Wrapper() as unknown as VDomNode render(vDom, app!) But it won't work, since when parsing the JSX, tag is just the label name. Sure, for native elements, it is just a string, but for components, it is a function. So in the process of converting JSX to vDOM, we need to check if the tag is a function, and if so, call it. export function createElement(tag: string | Function, props: VDomAttributes, ...children: VDomNode[]): VDomElement { if (tag instanceof Function) { return tag(props, children) } return { kind: tag === '' ? 'fragment' : 'element', tag, children, props: props ?? {}, key: props?.key ?? undefined } } Now, props and children are required for each component. In real React, they added extra field to check- you can imagine, just by replacing functions with classes, so you have extra fields- then you provide new function to create objects, a typical factory pattern- but we take a lazy we here. import { render } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; type FuncComponent = (props: VDomAttributes, children: VDomNode[]) => JSX.Element const Wrapper: FuncComponent = (_: VDomAttributes, __: VDomNode[]) => { return <div> <> <p>aa</p> </> </div> } const app = document.getElementById('app') const vDom: VDomNode = Wrapper({}, []) as unknown as VDomNode console.log(vDom) render(vDom, app!) Please note that in the real React, the function component call is delayed to the fiber building stage. Nonetheless, we did so for convenience, and it doesn't really harm the purpose of this series.","title":"Nested Components"},{"location":"02/#fragment","text":"However, it's still not enough. Previously, we just treated fragment as div , which is not correct. But if you just replace that with a document fragment, it won't work. The reason for this is because fragments is a one-time container- which leads to a strange behaviour- like you cannot take real things out of it, and you can not nest them, and many strange things (really, why it just won't work simpler...). So, fuck, we need to dig this shit up. So the solution is that, we do not create DOM for fragment- we find the correct parent to add the DOM. We need, export function isFragment(value: VDomNode): value is VDomElement { return isElement(value) && value.kind === 'fragment' } And change the rendering, function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom)) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip = null } Now, the fragment is correctly handled.","title":"Fragment"},{"location":"03/","text":"Tiny React Ch3 Updating vDOM Now let's talk about the reactivity. Save the Old Fiber We need to save the old fiber so that we can compare it with the new fiber. We can do this by adding a field to the fiber. We also need a committed field- which will be useful later. export interface Fiber { type: string props: VDomAttributes parent: Fiber | null child: Fiber | null sibling: Fiber | null dom: HTMLElement | Text | null alternate: Fiber | null committed: boolean } Then we set the committed state here, function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent.dom.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true wip = null } We also need to save the old fiber tree. let oldFiber: Fiber | null = null function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent.dom.appendChild(fiber.dom) fiber.committed = true } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } Now, we need to compare the old fiber with the new fiber during iteration. This is called the reconciliation process. Reconciliation We need to compare the old fiber with the new fiber. We first put the old fiber in the initial work. export function render(vDom: VDomNode, parent: HTMLElement) { wip = { parent: null, sibling: null, child: null, vDom: vDom, dom: null, committed: false, alternate: oldFiber, } wipParent = parent nextUnitOfWork = wip } Then we separate the creation of the new fiber into a new function. function reconcile(fiber: Fiber, isFragment: boolean) { if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: isFragment ? fiber.parent : fiber, dom: null, sibling: null, child: null, vDom: element, committed: false, alternate: null, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber index++ } } } function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { if(!nextUnitOfWork) { return null } const fiber = nextUnitOfWork const isFragment = isElement(fiber.vDom) && fiber.vDom.tag === '' && fiber.vDom.kind === 'fragment' if(!fiber.dom && !isFragment) { fiber.dom = createDom(fiber.vDom) } reconcile(fiber, isFragment) if (fiber.child) { return fiber.child } let nextFiber: Fiber | null = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } return null } However, we need to mount the old fiber onto the new one. function reconcile(fiber: Fiber, isFragment: boolean) { if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null let currentOldFiber = fiber.alternate?.child ?? null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: isFragment ? fiber.parent : fiber, dom: null, sibling: null, child: null, vDom: element, committed: false, alternate: currentOldFiber, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber currentOldFiber = currentOldFiber?.sibling ?? null index++ } } } Now we have the old fiber mounted to the new fiber. But we don't have anything to trigger the re-rendering- for now, we manually trigger it by adding a button. Since we don't yet have state yet, we use props for mutating the vDOM. import { render } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; type FuncComponent = (props: VDomAttributes, children: VDomNode[]) => JSX.Element const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { return <div> <> <h1>H1</h1> <h2>{props[\"example\"]?.toString()}</h2> { props[\"show\"] ? <p>show</p> : <></> } <h1>H1</h1> </> </div> } const app = document.getElementById('app') const renderButton = document.createElement('button') renderButton.textContent = 'Render' let cnt = 0 renderButton.addEventListener('click', () => { const vDom: VDomNode = App({ \"example\": (new Date()).toString(), \"show\": cnt % 2 === 0 }, []) as unknown as VDomNode cnt++ render(vDom, app!) }) document.body.appendChild(renderButton) Now if you click the renderButton , the rendered result will repeat once, since, well, all our current logic is simply putting the rendered vDOM into the document. If you add a console.log in the commit function, you can see the alternate fiber being printed out. Now we need to define how we handle the old fiber and the new fiber, and mutate the DOM based on the information. The rules is as follows. For each new fiber, If there was an old fiber, we compare the content of the old fiber with the new fiber, if they are different, we replace the old DOM node with the new DOM node, or else we copy the old DOM node to the new DOM node. Please note that, by two vDOM being equal, we mean their tags and all properties are equal. Their children can be different. If there has no old fiber, we create a new DOM node and append it to the parent. If, for the new fiber, it doesn't have a child or a sibling, but its old fiber has a child or a sibling, we recursively remove the old child or sibling. Kind of confused? Well, I'll just show the code. We first delete the old DOM creation. Then apply the rules above. The first rule, if there is an old fiber, we compare the content of the old fiber with the new fiber. If they are different, we replace the old DOM node with the new DOM node, or else we copy the old DOM node to the new DOM node. export function vDOMEquals(a: VDomNode, b: VDomNode): boolean { if (isString(a) && isString(b)) { return a === b } else if (isElement(a) && isElement(b)) { let ret = a.tag === b.tag && a.key === b.key if (!ret) return false if (a.props && b.props) { const aProps = a.props const bProps = b.props const aKeys = Object.keys(aProps) const bKeys = Object.keys(bProps) if (aKeys.length !== bKeys.length) return false for (let i = 0; i < aKeys.length; i++) { const key = aKeys[i] if (key === 'key') continue if (aProps[key] !== bProps[key]) return false } for (let i = 0; i < bKeys.length; i++) { const key = bKeys[i] if (key === 'key') continue if (aProps[key] !== bProps[key]) return false } return true } else { return a.props === b.props } } else { return false } } Then I made some small refactor, function buildDom(fiber: Fiber, fiberIsFragment: boolean) { if(fiber.dom) return if(fiberIsFragment) return fiber.dom = createDom(fiber.vDom) } function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { if(!nextUnitOfWork) { return null } const fiber = nextUnitOfWork const fiberIsFragment = isFragment(fiber.vDom) reconcile(fiber) buildDom(fiber, fiberIsFragment); if (fiber.child) { return fiber.child } let nextFiber: Fiber | null = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } return null } Now, when it comes to commit, we have an extra alternative field to compare the old fiber with the new fiber. This is the original commit function, function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } We will change the name a bit. The old name is just wrong (I'm sorry for that). function commit() { function commitToParent(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } Appending, Copying and Replacing So what should we do? Our old logic is only appending, so we extract that, function commit() { function append(fiber: Fiber) { if(!fiber.dom) return if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } } function commitToParent(fiber: Fiber | null) { if(!fiber) { return } append(fiber) commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } We need to delay the construction of the DOM until the commit phase, to provide more flexibility. function commit() { function append(fiber: Fiber) { if(isFragment(fiber.vDom)) return; fiber.dom = createDom(fiber.vDom) if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } } function commitToParent(fiber: Fiber | null) { if(!fiber) { return } append(fiber) commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } function reconcile(fiber: Fiber) { if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null let currentOldFiber = fiber.alternate?.child ?? null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: fiber, dom: null, sibling: null, child: null, vDom: element, committed: false, alternate: currentOldFiber, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber currentOldFiber = currentOldFiber?.sibling ?? null index++ } } } Following the first and second rule, we refactor them into the following code, function commit() { function findNonFragmentParent(fiber: Fiber): Fiber | null { let parent = fiber.parent while(parent && isFragment(parent.vDom)) { parent = parent.parent! } return parent } function append(fiber: Fiber) { if(isFragment(fiber.vDom)) return; if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { const parent = findNonFragmentParent(fiber); parent?.dom?.appendChild(fiber.dom!) fiber.committed = true } } function commitToParent(fiber: Fiber | null) { if(!fiber) { return } if(!fiber.alternate && !isFragment(fiber.vDom)) { fiber.dom = createDom(fiber.vDom) append(fiber) } if(fiber.alternate && vDOMEquals(fiber.vDom, fiber.alternate.vDom)) { fiber.dom = fiber.alternate.dom append(fiber) } if(fiber.alternate && !vDOMEquals(fiber.vDom, fiber.alternate.vDom) && !isFragment(fiber.vDom)) { fiber.dom = createDom(fiber.vDom) fiber.alternate.dom?.replaceWith(fiber.dom) append(fiber) } commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } Please always keep in mind that in javascript, all values are references. If we have fiber.dom = fiber.alternate.dom , then fiber.dom and fiber.alternate.dom will point to the same object. If we change fiber.dom , fiber.alternate.dom will also change, and vice versa. That's why when replacing, we simply used fiber.alternate.dom?.replaceWith(fiber.dom) . This will replace the old DOM with the new DOM. While previous parents, if copied, have the fiber.alternate.dom for their DOM, their DOM will also be replaced. However, we hadn't handled deletion yet. Some Mishaps Okay, previous code contains some bugs that I spotted as I am writing more complex jsx, so, before implementing the deletion, let's fix them. Previously there was a bug- we can not pass list to props , let's use this chance to fix it. export type VDomAttributes = { key?: string | number [_: string]: unknown | undefined } Then you just fix the type things- only one error for me, so, do it yourself please. However, if we have the following code, import { render } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; type FuncComponent = (props: VDomAttributes, children: VDomNode[]) => JSX.Element const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { return <div> { props[\"show\"] ? <h2>show</h2> : <></> } <ul> { (props[\"list\"] as Array<number>).map((i) => { return (<ul>{i}</ul>) }) } </ul> </div> } const app = document.getElementById('app') const renderButton = document.createElement('button') renderButton.textContent = 'Render' let cnt = 0 renderButton.addEventListener('click', () => { const vDom: VDomNode = App({ \"example\": (new Date()).toString(), \"show\": cnt % 2 === 0, \"list\": Array.from({ length: 10 - cnt }, (_, i) => i) }, []) as unknown as VDomNode cnt++ console.log(vDom) render(vDom, app!) }) document.body.appendChild(renderButton) Our thing broke again... Okay, this is because children can be nested arrays in the above case, we need to flat them. But that's not enough, ugh, our createDom only recognize either string or element, not integer, so, we need toString the numbers. (props[\"list\"] as Array<number>).map((i) => { return (<ul>{i.toString()}</ul>) }) Okay, things work now- kind of. If you hit the render button, the list is updated- but the old element still remains. We need to delete the old element. Remove We restate the rule here- for any new fiber, if it does not have a child or a sibling, but its old fiber has a child or a sibling, we recursively remove the old child or sibling. function recursiveRemoveRelated(fiber: Fiber | null) { if(!fiber) { return } if(fiber.sibling) { recursiveRemoveRelated(fiber.sibling) fiber.sibling.dom?.remove() } if(fiber.child) { recursiveRemoveRelated(fiber.child) fiber.child.dom?.remove() } } if(fiber.alternate?.child && !fiber.child) { recursiveRemoveRelated(fiber.alternate.child) fiber.alternate.child.dom?.remove() } if(fiber.alternate?.sibling && !fiber.sibling) { recursiveRemoveRelated(fiber.alternate.sibling) fiber.alternate.sibling.dom?.remove() } If you don't do recursive remove, some old elements will dangle when you have multiple things requires deletion. You can change to, renderButton.addEventListener('click', () => { const vDom: VDomNode = App({ \"example\": (new Date()).toString(), \"show\": cnt % 2 === 0, \"list\": Array.from({ length: 10 - cnt * 2 }, (_, i) => i) }, []) as unknown as VDomNode cnt++ console.log(vDom) render(vDom, app!) }) For reference. Summary This is a hard chapter- but pretty traditional coding, to be honest. However, up to now, you have understand how React works from bottom to top. Actually, things can already work now- we can manually trigger a re-render whenever we change the props. However, such frustrating manual work is not what we want. We want the reactivity to be automatic. So, we will talk about hooks in the next chapter.","title":"Updating vDOM"},{"location":"03/#tiny-react-ch3-updating-vdom","text":"Now let's talk about the reactivity.","title":"Tiny React Ch3 Updating vDOM"},{"location":"03/#save-the-old-fiber","text":"We need to save the old fiber so that we can compare it with the new fiber. We can do this by adding a field to the fiber. We also need a committed field- which will be useful later. export interface Fiber { type: string props: VDomAttributes parent: Fiber | null child: Fiber | null sibling: Fiber | null dom: HTMLElement | Text | null alternate: Fiber | null committed: boolean } Then we set the committed state here, function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent.dom.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true wip = null } We also need to save the old fiber tree. let oldFiber: Fiber | null = null function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent.dom.appendChild(fiber.dom) fiber.committed = true } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } Now, we need to compare the old fiber with the new fiber during iteration. This is called the reconciliation process.","title":"Save the Old Fiber"},{"location":"03/#reconciliation","text":"We need to compare the old fiber with the new fiber. We first put the old fiber in the initial work. export function render(vDom: VDomNode, parent: HTMLElement) { wip = { parent: null, sibling: null, child: null, vDom: vDom, dom: null, committed: false, alternate: oldFiber, } wipParent = parent nextUnitOfWork = wip } Then we separate the creation of the new fiber into a new function. function reconcile(fiber: Fiber, isFragment: boolean) { if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: isFragment ? fiber.parent : fiber, dom: null, sibling: null, child: null, vDom: element, committed: false, alternate: null, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber index++ } } } function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { if(!nextUnitOfWork) { return null } const fiber = nextUnitOfWork const isFragment = isElement(fiber.vDom) && fiber.vDom.tag === '' && fiber.vDom.kind === 'fragment' if(!fiber.dom && !isFragment) { fiber.dom = createDom(fiber.vDom) } reconcile(fiber, isFragment) if (fiber.child) { return fiber.child } let nextFiber: Fiber | null = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } return null } However, we need to mount the old fiber onto the new one. function reconcile(fiber: Fiber, isFragment: boolean) { if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null let currentOldFiber = fiber.alternate?.child ?? null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: isFragment ? fiber.parent : fiber, dom: null, sibling: null, child: null, vDom: element, committed: false, alternate: currentOldFiber, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber currentOldFiber = currentOldFiber?.sibling ?? null index++ } } } Now we have the old fiber mounted to the new fiber. But we don't have anything to trigger the re-rendering- for now, we manually trigger it by adding a button. Since we don't yet have state yet, we use props for mutating the vDOM. import { render } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; type FuncComponent = (props: VDomAttributes, children: VDomNode[]) => JSX.Element const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { return <div> <> <h1>H1</h1> <h2>{props[\"example\"]?.toString()}</h2> { props[\"show\"] ? <p>show</p> : <></> } <h1>H1</h1> </> </div> } const app = document.getElementById('app') const renderButton = document.createElement('button') renderButton.textContent = 'Render' let cnt = 0 renderButton.addEventListener('click', () => { const vDom: VDomNode = App({ \"example\": (new Date()).toString(), \"show\": cnt % 2 === 0 }, []) as unknown as VDomNode cnt++ render(vDom, app!) }) document.body.appendChild(renderButton) Now if you click the renderButton , the rendered result will repeat once, since, well, all our current logic is simply putting the rendered vDOM into the document. If you add a console.log in the commit function, you can see the alternate fiber being printed out. Now we need to define how we handle the old fiber and the new fiber, and mutate the DOM based on the information. The rules is as follows. For each new fiber, If there was an old fiber, we compare the content of the old fiber with the new fiber, if they are different, we replace the old DOM node with the new DOM node, or else we copy the old DOM node to the new DOM node. Please note that, by two vDOM being equal, we mean their tags and all properties are equal. Their children can be different. If there has no old fiber, we create a new DOM node and append it to the parent. If, for the new fiber, it doesn't have a child or a sibling, but its old fiber has a child or a sibling, we recursively remove the old child or sibling. Kind of confused? Well, I'll just show the code. We first delete the old DOM creation. Then apply the rules above. The first rule, if there is an old fiber, we compare the content of the old fiber with the new fiber. If they are different, we replace the old DOM node with the new DOM node, or else we copy the old DOM node to the new DOM node. export function vDOMEquals(a: VDomNode, b: VDomNode): boolean { if (isString(a) && isString(b)) { return a === b } else if (isElement(a) && isElement(b)) { let ret = a.tag === b.tag && a.key === b.key if (!ret) return false if (a.props && b.props) { const aProps = a.props const bProps = b.props const aKeys = Object.keys(aProps) const bKeys = Object.keys(bProps) if (aKeys.length !== bKeys.length) return false for (let i = 0; i < aKeys.length; i++) { const key = aKeys[i] if (key === 'key') continue if (aProps[key] !== bProps[key]) return false } for (let i = 0; i < bKeys.length; i++) { const key = bKeys[i] if (key === 'key') continue if (aProps[key] !== bProps[key]) return false } return true } else { return a.props === b.props } } else { return false } } Then I made some small refactor, function buildDom(fiber: Fiber, fiberIsFragment: boolean) { if(fiber.dom) return if(fiberIsFragment) return fiber.dom = createDom(fiber.vDom) } function performUnitOfWork(nextUnitOfWork: Fiber | null): Fiber | null { if(!nextUnitOfWork) { return null } const fiber = nextUnitOfWork const fiberIsFragment = isFragment(fiber.vDom) reconcile(fiber) buildDom(fiber, fiberIsFragment); if (fiber.child) { return fiber.child } let nextFiber: Fiber | null = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } return null } Now, when it comes to commit, we have an extra alternative field to compare the old fiber with the new fiber. This is the original commit function, function commit() { function commitChildren(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } commitChildren(fiber.child) commitChildren(fiber.sibling) } commitChildren(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } We will change the name a bit. The old name is just wrong (I'm sorry for that). function commit() { function commitToParent(fiber: Fiber | null) { if(!fiber) { return } if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null }","title":"Reconciliation"},{"location":"03/#appending-copying-and-replacing","text":"So what should we do? Our old logic is only appending, so we extract that, function commit() { function append(fiber: Fiber) { if(!fiber.dom) return if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } } function commitToParent(fiber: Fiber | null) { if(!fiber) { return } append(fiber) commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } We need to delay the construction of the DOM until the commit phase, to provide more flexibility. function commit() { function append(fiber: Fiber) { if(isFragment(fiber.vDom)) return; fiber.dom = createDom(fiber.vDom) if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { let parent = fiber.parent // find the first parent that is not a fragment while(parent && isFragment(parent.vDom)) { // the root element is guaranteed to not be a fragment has has a non-fragment parent parent = parent.parent! } parent.dom?.appendChild(fiber.dom!) fiber.committed = true } } function commitToParent(fiber: Fiber | null) { if(!fiber) { return } append(fiber) commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } function reconcile(fiber: Fiber) { if (isElement(fiber.vDom)) { const elements = fiber.vDom.children ?? [] let index = 0 let prevSibling = null let currentOldFiber = fiber.alternate?.child ?? null while (index < elements.length) { const element = elements[index] const newFiber: Fiber = { parent: fiber, dom: null, sibling: null, child: null, vDom: element, committed: false, alternate: currentOldFiber, } if (index === 0) { fiber.child = newFiber } else { prevSibling!.sibling = newFiber } prevSibling = newFiber currentOldFiber = currentOldFiber?.sibling ?? null index++ } } } Following the first and second rule, we refactor them into the following code, function commit() { function findNonFragmentParent(fiber: Fiber): Fiber | null { let parent = fiber.parent while(parent && isFragment(parent.vDom)) { parent = parent.parent! } return parent } function append(fiber: Fiber) { if(isFragment(fiber.vDom)) return; if(fiber.dom && fiber.parent?.dom) { fiber.parent?.dom?.appendChild(fiber.dom) fiber.committed = true } if(fiber.dom && fiber.parent && isFragment(fiber.parent.vDom) && !fiber.committed) { const parent = findNonFragmentParent(fiber); parent?.dom?.appendChild(fiber.dom!) fiber.committed = true } } function commitToParent(fiber: Fiber | null) { if(!fiber) { return } if(!fiber.alternate && !isFragment(fiber.vDom)) { fiber.dom = createDom(fiber.vDom) append(fiber) } if(fiber.alternate && vDOMEquals(fiber.vDom, fiber.alternate.vDom)) { fiber.dom = fiber.alternate.dom append(fiber) } if(fiber.alternate && !vDOMEquals(fiber.vDom, fiber.alternate.vDom) && !isFragment(fiber.vDom)) { fiber.dom = createDom(fiber.vDom) fiber.alternate.dom?.replaceWith(fiber.dom) append(fiber) } commitToParent(fiber.child) commitToParent(fiber.sibling) } commitToParent(wip) wipParent?.appendChild(wip!.dom!) wip!.committed = true oldFiber = wip wip = null } Please always keep in mind that in javascript, all values are references. If we have fiber.dom = fiber.alternate.dom , then fiber.dom and fiber.alternate.dom will point to the same object. If we change fiber.dom , fiber.alternate.dom will also change, and vice versa. That's why when replacing, we simply used fiber.alternate.dom?.replaceWith(fiber.dom) . This will replace the old DOM with the new DOM. While previous parents, if copied, have the fiber.alternate.dom for their DOM, their DOM will also be replaced. However, we hadn't handled deletion yet.","title":"Appending, Copying and Replacing"},{"location":"03/#some-mishaps","text":"Okay, previous code contains some bugs that I spotted as I am writing more complex jsx, so, before implementing the deletion, let's fix them. Previously there was a bug- we can not pass list to props , let's use this chance to fix it. export type VDomAttributes = { key?: string | number [_: string]: unknown | undefined } Then you just fix the type things- only one error for me, so, do it yourself please. However, if we have the following code, import { render } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; type FuncComponent = (props: VDomAttributes, children: VDomNode[]) => JSX.Element const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { return <div> { props[\"show\"] ? <h2>show</h2> : <></> } <ul> { (props[\"list\"] as Array<number>).map((i) => { return (<ul>{i}</ul>) }) } </ul> </div> } const app = document.getElementById('app') const renderButton = document.createElement('button') renderButton.textContent = 'Render' let cnt = 0 renderButton.addEventListener('click', () => { const vDom: VDomNode = App({ \"example\": (new Date()).toString(), \"show\": cnt % 2 === 0, \"list\": Array.from({ length: 10 - cnt }, (_, i) => i) }, []) as unknown as VDomNode cnt++ console.log(vDom) render(vDom, app!) }) document.body.appendChild(renderButton) Our thing broke again... Okay, this is because children can be nested arrays in the above case, we need to flat them. But that's not enough, ugh, our createDom only recognize either string or element, not integer, so, we need toString the numbers. (props[\"list\"] as Array<number>).map((i) => { return (<ul>{i.toString()}</ul>) }) Okay, things work now- kind of. If you hit the render button, the list is updated- but the old element still remains. We need to delete the old element.","title":"Some Mishaps"},{"location":"03/#remove","text":"We restate the rule here- for any new fiber, if it does not have a child or a sibling, but its old fiber has a child or a sibling, we recursively remove the old child or sibling. function recursiveRemoveRelated(fiber: Fiber | null) { if(!fiber) { return } if(fiber.sibling) { recursiveRemoveRelated(fiber.sibling) fiber.sibling.dom?.remove() } if(fiber.child) { recursiveRemoveRelated(fiber.child) fiber.child.dom?.remove() } } if(fiber.alternate?.child && !fiber.child) { recursiveRemoveRelated(fiber.alternate.child) fiber.alternate.child.dom?.remove() } if(fiber.alternate?.sibling && !fiber.sibling) { recursiveRemoveRelated(fiber.alternate.sibling) fiber.alternate.sibling.dom?.remove() } If you don't do recursive remove, some old elements will dangle when you have multiple things requires deletion. You can change to, renderButton.addEventListener('click', () => { const vDom: VDomNode = App({ \"example\": (new Date()).toString(), \"show\": cnt % 2 === 0, \"list\": Array.from({ length: 10 - cnt * 2 }, (_, i) => i) }, []) as unknown as VDomNode cnt++ console.log(vDom) render(vDom, app!) }) For reference.","title":"Remove"},{"location":"03/#summary","text":"This is a hard chapter- but pretty traditional coding, to be honest. However, up to now, you have understand how React works from bottom to top. Actually, things can already work now- we can manually trigger a re-render whenever we change the props. However, such frustrating manual work is not what we want. We want the reactivity to be automatic. So, we will talk about hooks in the next chapter.","title":"Summary"},{"location":"04/","text":"Tiny React Ch04 Hooks Okay, before diving into hooks, we need a bit wrap up on the last chapter- still something to fix, but the last chapter was too much, so, well, here it is. Fixing the last chapter Here are some minor things- not entirely bugs, but better to fix them. vDOM Comparison In javascript, two functions are equal only if they are the same, stays unequal even if they have the same procedure, that is, const a = () => 1; const b = () => 1; a === b; // false So, when it comes to vDOM Comparison, we should skip the function comparison. Here is the fix, for (let i = 0; i < aKeys.length; i++) { const key = aKeys[i] if (key === 'key') continue if (aProps[key] instanceof Function && bProps[key] instanceof Function) continue if (aProps[key] !== bProps[key]) return false } for (let i = 0; i < bKeys.length; i++) { const key = bKeys[i] if (key === 'key') continue if (aProps[key] instanceof Function && bProps[key] instanceof Function) continue if (aProps[key] !== bProps[key]) return false } Handling CSS Style should be treated as a special property that is attributed to element with .style property. Here is the fix, export type VDomAttributes = { key?: string | number style?: object [_: string]: unknown | undefined } export function createDom(vDom: VDomNode): HTMLElement | Text { if (isElement(vDom)) { const element = document.createElement(vDom.tag) Object.entries(vDom.props ?? {}).forEach(([name, value]) => { if (value === undefined) return if (name === 'key') return if (name === 'style') { Object.entries(value as Record<string, unknown>).forEach(([styleName, styleValue]) => { element.style[styleName as any] = styleValue as any }) return } if (name.startsWith('on') && value instanceof Function) { element.addEventListener(name.slice(2).toLowerCase(), value as EventListener) } else { element.setAttribute(name, value?.toString() ?? \"\") } }) return element } else { return document.createTextNode(vDom) } } Now these side fixes are done, let's move on to the main topic of this chapter- Hooks. Capsuling vDOM Creation We previously explicitly called render(vDom, app!) , which requires creating vDOM by user, here is a better way to do it. import { mount, useState, type FuncComponent } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { const [cnt, setCnt] = useState(0) return <div> <button onClick={() => setCnt(cnt() + 1)}>Click me</button> <p>Count: {cnt()}</p> </div> } const app = document.getElementById('app') mount(App, {}, [], app!) let reRender: () => void = () => {} export function mount(app: FuncComponent, props: VDomAttributes, children: VDomNode[], parent: HTMLElement) { reRender = () => { const vDom = app(props, children) as unknown as VDomNode render(vDom, parent) } reRender() } Looks better more or less. Now let's move on to the main topic of this chapter- Hooks. useState Okay, let's get to the hook. The first hook we are going to implement is useState . It is a hook that allows us to manage the state of a component. We can have the following signature for useState , Note that our implementation is slightly different from the original React. We are going to return a getter and a setter function, instead of returning the state directly. function useState<T>(initialValue: T): [() => T, (newValue: T) => void] { // implementation } So where will we hook the value at? If we just hide it within the closure itself, the value will be lost when the component is re-rendered. If you insist on doing so, you need to access the space of the outer function, which is not possible in javascript. So our way is to store it, you guessed it, in fiber. So, let's add a field to the fiber. interface Fiber { parent: Fiber | null sibling: Fiber | null child: Fiber | null vDom: VDomNode dom: HTMLElement | Text | null alternate: Fiber | null committed: boolean hooks?: { state: unknown[] }, hookIndex?: { state: number } } And we only mount hooks to the root fiber, so we can add the following line to the mount function. export function render(vDom: VDomNode, parent: HTMLElement) { wip = { parent: null, sibling: null, child: null, vDom: vDom, dom: null, committed: false, alternate: oldFiber, hooks: oldFiber?.hooks ?? { state: [] }, hookIndex: { state: 0 } } wipParent = parent nextUnitOfWork = wip } Hook index will come into use later. Now, hook index resets every time the component is re-rendered, but old hooks are carried over. Please note that, we rendering component vDOM, only old fiber is accessible, so we can only manipulate that variable. However, it is null at the very beginning, so let's set up a dummy. export function mount(app: FuncComponent, props: VDomAttributes, children: VDomNode[], parent: HTMLElement) { reRender = () => { if(!oldFiber) { oldFiber = { parent: null, sibling: null, child: null, vDom: null as any, dom: null, committed: false, alternate: null, hooks: { state: [] }, hookIndex: { state: 0 } } } const vDom = app(props, children) as unknown as VDomNode render(vDom, parent) console.log('rerender') console.log(vDom) } reRender() } Now we will have big brain time- since the order of each hook call is fixed (you can not use hooks in a loop or a condition, basic React rule, you know why it is now), so we can use safely use hookIndex to access the hook. export function useState<T>(initialState: T): [T, (newState: T) => void] { const hookIndex = oldFiber!.hookIndex!.state oldFiber!.hookIndex!.state++ oldFiber!.hooks!.state[hookIndex] = oldFiber!.hooks!.state[hookIndex] ?? initialState console.log(oldFiber!.hooks!.state) const state = oldFiber!.hooks!.state[hookIndex] const setState = (newState: T) => { oldFiber!.hooks!.state[hookIndex] = newState reRender!() } return [state as T, setState] } Well, let's try, import { mount, useState, type FuncComponent } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { const [cnt, setCnt] = useState(0) return <div> <button onClick={() => setCnt(cnt + 1)}>Click me</button> <p>Count: {cnt}</p> </div> } const app = document.getElementById('app') mount(App, {}, [], app!) It kind of works- the count increased from zero to one, but it does not increase further. Well... strange right? Let's see what's going on, debug time. const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { const [cnt, setCnt] = useState(0) return <div> <button onClick={() => { console.log(cnt + 1) console.log(\"FROM COMPONENT\") setCnt(cnt + 1) }}>Click me</button> <p>Count: {cnt}</p> </div> } const app = document.getElementById('app') mount(App, {}, [], app!) You will see that, it always log 1. But the web page tells us that it is 1, so it should be 2. What's going on? For native types, javascript passes by value, so the value is copied, not referenced. In React class component, it requires you to have a state object to address the issues. In functional component, the React addresses with, closure. But if we were to use the latter, it requires a big change in our code. So a simple way to get pass is, using function to get the state, so that the function will always return the latest state. export function useState<T>(initialState: T): [() => T, (newState: T) => void] { const hookIndex = oldFiber!.hookIndex!.state oldFiber!.hookIndex!.state++ oldFiber!.hooks!.state[hookIndex] = oldFiber!.hooks!.state[hookIndex] ?? initialState console.log(oldFiber!.hooks!.state) const state = () => oldFiber!.hooks!.state[hookIndex] as T const setState = (newState: T) => { oldFiber!.hooks!.state[hookIndex] = newState reRender!() } return [state, setState] } And now, here we got it! It works! We created the useState hook for our tiny React. Summary Okay, you may believe that this chapter is too short- hooks are important to react, so why did we only implement useState ? First, many hooks are just variations of useState . Such hook is irrelevant to the component it is called, for example, useMemo . Such things are just trivial works and we got no time to waste. But, second, the most important reason, is that, for hooks like useEffect , under our current, root-update based frame, they are nearly impossible to do. When a fiber unmount, you can not signal, because we only fetch the global vDOM and update the whole vDOM, whereas, in real React, it's not like so. In real React, functional components are updated by the parent component, so the parent component can signal the child component to unmount. But in our case, we only update the root component, so we can not signal the child component to unmount.","title":"Hooks"},{"location":"04/#tiny-react-ch04-hooks","text":"Okay, before diving into hooks, we need a bit wrap up on the last chapter- still something to fix, but the last chapter was too much, so, well, here it is.","title":"Tiny React Ch04 Hooks"},{"location":"04/#fixing-the-last-chapter","text":"Here are some minor things- not entirely bugs, but better to fix them.","title":"Fixing the last chapter"},{"location":"04/#vdom-comparison","text":"In javascript, two functions are equal only if they are the same, stays unequal even if they have the same procedure, that is, const a = () => 1; const b = () => 1; a === b; // false So, when it comes to vDOM Comparison, we should skip the function comparison. Here is the fix, for (let i = 0; i < aKeys.length; i++) { const key = aKeys[i] if (key === 'key') continue if (aProps[key] instanceof Function && bProps[key] instanceof Function) continue if (aProps[key] !== bProps[key]) return false } for (let i = 0; i < bKeys.length; i++) { const key = bKeys[i] if (key === 'key') continue if (aProps[key] instanceof Function && bProps[key] instanceof Function) continue if (aProps[key] !== bProps[key]) return false }","title":"vDOM Comparison"},{"location":"04/#handling-css","text":"Style should be treated as a special property that is attributed to element with .style property. Here is the fix, export type VDomAttributes = { key?: string | number style?: object [_: string]: unknown | undefined } export function createDom(vDom: VDomNode): HTMLElement | Text { if (isElement(vDom)) { const element = document.createElement(vDom.tag) Object.entries(vDom.props ?? {}).forEach(([name, value]) => { if (value === undefined) return if (name === 'key') return if (name === 'style') { Object.entries(value as Record<string, unknown>).forEach(([styleName, styleValue]) => { element.style[styleName as any] = styleValue as any }) return } if (name.startsWith('on') && value instanceof Function) { element.addEventListener(name.slice(2).toLowerCase(), value as EventListener) } else { element.setAttribute(name, value?.toString() ?? \"\") } }) return element } else { return document.createTextNode(vDom) } } Now these side fixes are done, let's move on to the main topic of this chapter- Hooks.","title":"Handling CSS"},{"location":"04/#capsuling-vdom-creation","text":"We previously explicitly called render(vDom, app!) , which requires creating vDOM by user, here is a better way to do it. import { mount, useState, type FuncComponent } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { const [cnt, setCnt] = useState(0) return <div> <button onClick={() => setCnt(cnt() + 1)}>Click me</button> <p>Count: {cnt()}</p> </div> } const app = document.getElementById('app') mount(App, {}, [], app!) let reRender: () => void = () => {} export function mount(app: FuncComponent, props: VDomAttributes, children: VDomNode[], parent: HTMLElement) { reRender = () => { const vDom = app(props, children) as unknown as VDomNode render(vDom, parent) } reRender() } Looks better more or less. Now let's move on to the main topic of this chapter- Hooks.","title":"Capsuling vDOM Creation"},{"location":"04/#usestate","text":"Okay, let's get to the hook. The first hook we are going to implement is useState . It is a hook that allows us to manage the state of a component. We can have the following signature for useState , Note that our implementation is slightly different from the original React. We are going to return a getter and a setter function, instead of returning the state directly. function useState<T>(initialValue: T): [() => T, (newValue: T) => void] { // implementation } So where will we hook the value at? If we just hide it within the closure itself, the value will be lost when the component is re-rendered. If you insist on doing so, you need to access the space of the outer function, which is not possible in javascript. So our way is to store it, you guessed it, in fiber. So, let's add a field to the fiber. interface Fiber { parent: Fiber | null sibling: Fiber | null child: Fiber | null vDom: VDomNode dom: HTMLElement | Text | null alternate: Fiber | null committed: boolean hooks?: { state: unknown[] }, hookIndex?: { state: number } } And we only mount hooks to the root fiber, so we can add the following line to the mount function. export function render(vDom: VDomNode, parent: HTMLElement) { wip = { parent: null, sibling: null, child: null, vDom: vDom, dom: null, committed: false, alternate: oldFiber, hooks: oldFiber?.hooks ?? { state: [] }, hookIndex: { state: 0 } } wipParent = parent nextUnitOfWork = wip } Hook index will come into use later. Now, hook index resets every time the component is re-rendered, but old hooks are carried over. Please note that, we rendering component vDOM, only old fiber is accessible, so we can only manipulate that variable. However, it is null at the very beginning, so let's set up a dummy. export function mount(app: FuncComponent, props: VDomAttributes, children: VDomNode[], parent: HTMLElement) { reRender = () => { if(!oldFiber) { oldFiber = { parent: null, sibling: null, child: null, vDom: null as any, dom: null, committed: false, alternate: null, hooks: { state: [] }, hookIndex: { state: 0 } } } const vDom = app(props, children) as unknown as VDomNode render(vDom, parent) console.log('rerender') console.log(vDom) } reRender() } Now we will have big brain time- since the order of each hook call is fixed (you can not use hooks in a loop or a condition, basic React rule, you know why it is now), so we can use safely use hookIndex to access the hook. export function useState<T>(initialState: T): [T, (newState: T) => void] { const hookIndex = oldFiber!.hookIndex!.state oldFiber!.hookIndex!.state++ oldFiber!.hooks!.state[hookIndex] = oldFiber!.hooks!.state[hookIndex] ?? initialState console.log(oldFiber!.hooks!.state) const state = oldFiber!.hooks!.state[hookIndex] const setState = (newState: T) => { oldFiber!.hooks!.state[hookIndex] = newState reRender!() } return [state as T, setState] } Well, let's try, import { mount, useState, type FuncComponent } from \"./runtime\"; import { createElement, fragment, VDomAttributes, VDomNode } from \"./v-dom\"; const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { const [cnt, setCnt] = useState(0) return <div> <button onClick={() => setCnt(cnt + 1)}>Click me</button> <p>Count: {cnt}</p> </div> } const app = document.getElementById('app') mount(App, {}, [], app!) It kind of works- the count increased from zero to one, but it does not increase further. Well... strange right? Let's see what's going on, debug time. const App: FuncComponent = (props: VDomAttributes, __: VDomNode[]) => { const [cnt, setCnt] = useState(0) return <div> <button onClick={() => { console.log(cnt + 1) console.log(\"FROM COMPONENT\") setCnt(cnt + 1) }}>Click me</button> <p>Count: {cnt}</p> </div> } const app = document.getElementById('app') mount(App, {}, [], app!) You will see that, it always log 1. But the web page tells us that it is 1, so it should be 2. What's going on? For native types, javascript passes by value, so the value is copied, not referenced. In React class component, it requires you to have a state object to address the issues. In functional component, the React addresses with, closure. But if we were to use the latter, it requires a big change in our code. So a simple way to get pass is, using function to get the state, so that the function will always return the latest state. export function useState<T>(initialState: T): [() => T, (newState: T) => void] { const hookIndex = oldFiber!.hookIndex!.state oldFiber!.hookIndex!.state++ oldFiber!.hooks!.state[hookIndex] = oldFiber!.hooks!.state[hookIndex] ?? initialState console.log(oldFiber!.hooks!.state) const state = () => oldFiber!.hooks!.state[hookIndex] as T const setState = (newState: T) => { oldFiber!.hooks!.state[hookIndex] = newState reRender!() } return [state, setState] } And now, here we got it! It works! We created the useState hook for our tiny React.","title":"useState"},{"location":"04/#summary","text":"Okay, you may believe that this chapter is too short- hooks are important to react, so why did we only implement useState ? First, many hooks are just variations of useState . Such hook is irrelevant to the component it is called, for example, useMemo . Such things are just trivial works and we got no time to waste. But, second, the most important reason, is that, for hooks like useEffect , under our current, root-update based frame, they are nearly impossible to do. When a fiber unmount, you can not signal, because we only fetch the global vDOM and update the whole vDOM, whereas, in real React, it's not like so. In real React, functional components are updated by the parent component, so the parent component can signal the child component to unmount. But in our case, we only update the root component, so we can not signal the child component to unmount.","title":"Summary"}]}